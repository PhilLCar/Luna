\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{inconsolata}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage[margin=1in]{geometry}
\usepackage[sfdefault]{roboto} 
\usepackage[T1]{fontenc}
\usepackage{color}
\usepackage{caption}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{textcomp}

\renewcommand{\arraystretch}{1.5}

\setcounter{secnumdepth}{3}
\titleformat*{\section}{\LARGE\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\title{Compilateur Lua - Projet IFT3150}
\date{\today}
\author{Philippe Caron}

\setlength{\emergencystretch}{1em}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{lgray}{rgb}{0.98,0.98,0.98}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{reserved}{rgb}{0.8,0,0.8}
\definecolor{comment}{rgb}{0.8,0,0}
\definecolor{def}{rgb}{0,0,1}
\definecolor{string}{rgb}{0.6, 0.05, 0.1}
\definecolor{no}{rgb}{1, 1, 1}

\captionsetup[lstlisting]{font=scriptsize, labelfont=bf}
\lstset{ %
  backgroundcolor=\color{lgray},   
  basicstyle=\normalsize\ttfamily,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b, 
  language=[5.3]Lua,
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,% lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,                   % how far the line-numbers are from the code
   % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,
                     % the step between two line-numbers. If it's 1, each line will be numbered   % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\lstdefinestyle{lua}{
  belowcaptionskip=0.5\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  language=[5.3]Lua,
  showstringspaces=false, 
  keepspaces=true,  
  commentstyle=\color{comment}, 
  keywordstyle=\bfseries\color{reserved}, 
  stringstyle=\color{string},  
  numbers=left,
  numbersep=5pt,                    % show tabs within strings adding particular underscores
  stepnumber=1,
  numberstyle=\tiny\color{gray}
  %identifierstyle=\color{blue},
}
\lstdefinestyle{out}{
  belowcaptionskip=-1\baselineskip,
  breaklines=true,
  xleftmargin=\parindent,
  showstringspaces=false, 
  keepspaces=true,
  language={},
  numberstyle=\tiny\color{no}
}
\renewcommand{\lstlistingname}{Exemple}
\newcommand{\luna}{\textbf{\texttt{Luna}}}

%\lstset{escapechar=@,style=customc}
%\newcommand{\includecode}[2][c]{\lstinputlisting[caption=#2, escapechar=, style=custom#1]{#2}<!---->}
% ...

%\includecode{sched.c}
%\includecode[asm]{sched.s}
% ...

%\lstlistoflistings

\begin{document}
\maketitle

\newpage
\section{Introduction}
Ce documents décrit le fonctionnement du compilateur \luna{} en détail.\luna{} est conçu pour compiler le langage Lua 5.3 et produit du code assembleur (syntaxe GAS) pour l'architecture de processeur Intel X86-64, pouvant être compilé par gcc sur un ordinateur Linux ou OSX.

\subsection{Le langage Lua 5.3}
Lua est un langage normalement utilisé pour les scripts, il est donc très simple, typé dynamiquement, et la gestion de mémoire est automatique. On pourrait dire que ces caractéristiques \textit{intuitives} pour l'humain le rendent relativement complexe à implémenter du côté machine. Il est normalement implémenté en C et roule sur une machine virtuelle \footnote{https://www.lua.org/manual/5.3/manual.html, 1 - Introduction}. Étant donné sa proximité avec C, il est possible d'appeler directement des fonction C depuis le code. Évidemment, le but ultime à vouloir compiler ce langage est de produire des fichiers exécutable par le processeur lui-même, il n'est donc pas question de perdre aucune des fonctionnalités originale du langage. C'est pourquoi le code compilé par \luna{} a aussi une collection de mémoire automatique, ainsi que la possibilité d'appeler une fonction C directement \footnote{La conversion de type n'est pas automatique, la fonction C est donc responsable de gérer la conversion de son côté}.

\subsubsection{Opérateurs}
Tous les opérateurs ont au moins un paramètre et au plus deux. Lors du stage de \textit{preprocessing} ils sont regroupés et parenthèsés adéquatement.
Tous les opérateurs du langage Lua sont supportés par \luna{}, et certains autres ont étés ajoutés. Voici la table complète des opérateurs et de leur priorité (le niveau 0 représentant la priorité la plus haute):
\paragraph{Table des priorité}
\begin{center}
  \begin{tabular}{c|l|c|l}
    Priorité & Niveau & Associativité & Opérateurs\\
    \hline\hline
    0 & Opération sur les bits & Gauche & {\lstinline$<< >> >>> | & ^^ === != ~$} \\
    \hline
    1 & Puissance & Droite & {\lstinline$^$}\\
    \hline
    2 & Opérateur unaire & Gauche &{\lstset{style=lua}\lstinline$- not ~ #$}\\
    \hline
    3 & Multiplicatif & Gauche & {\lstinline$* / % \ //$}\\
    \hline
    4 & Additif & Gauche & {\lstinline$+ -$}\\
    \hline
    5 & Concaténation & Droite & {\lstinline$..$}\\
    \hline
    6 & Booléen & Gauche & {\lstinline$== ~= <= >= < >$}\\
    \hline
    7 & Conjonctif & Gauche & {\lstset{style=lua}\lstinline$and$}\\
    \hline
    8 & Disjonctif &  Gauche & {\lstset{style=lua}\lstinline$or$}
  \end{tabular}
\end{center}
Le sens de l'associativité décrit dans quel ordre les expression vont se former si plusieurs d'entre elles du même niveau de priorité se trouvent côte-à-côte. Par exemple:
\begin{lstlisting}[style=lua,caption={Exemple du sens de l'associativité},label=DescriptiveLabel]
  x^y^z = (x ^ (y ^ z) --droite
  1-2-3 = ((1 - 2) - 3) --gauche
\end{lstlisting}
Pour de plus amples détails vous pouver consulter le jeu d'instruction du au paragraphe \ref{par:instructions}.
\newpage
\subsubsection{Types et repésentation interne}
Vu que Lua est typé dynamiquement, chaque variable doit contenir son information de type. On tire profit du fait que les pointeur n'occupent que 6 bytes les plus bas pour stocker l'information de type. En décalant les pointeurs de 3 bits vers la gauche, on obtient suffisemment d'espace pour encore 8 types différents. Pour récupérer les types on fait 'AND' avec 7, et pour récupérer le pointeur 'SAR' avec 3. Le paragraphe suivant décrit les types et leur représentation interne. À des fins de clareté on fera référence à toutes les valeurs qui ont leur 3 LSB libre comme étant étiquetées (T: \textit{tagged}) et toutes celles étant dans leur format \textit{naturel} comme étant non-étiquetées (UT: \textit{untagged}). Voici un tableau de référence pour comprendre les schéma de représentation interne:


\vspace{1.5cm}
\begin{center}
  \begin{tabular}{c|p{12cm}}
    \textbf{Abbréviation} & \textbf{Signification}\\
    \hline\hline
    \texttt{Ptr} & Pointeur\\
    \hline
    \texttt{Int} & Entier\\
    \hline
    \texttt{Float} & Nombre à virgule flottante\\
    \hline
    \texttt{Byte} & Octet\\
    \hline
    \texttt{Fct} & Fonction\\
    \hline
    \texttt{UT} & Représentation naturelle\\
    \hline
    \texttt{T} & Le nombre est décalé de 3 bits vers la gauche et étiqueté\\
    \hline
    \texttt{+} & La case est occupée par une valeur\\
    \hline
    \texttt{*} & La case est occupée par un pointeur\\
    \hline
    \texttt{\#{}} & La case est occupée par une valeur quelconque (peut être un pointeur ou une valeur)\\
    \hline
    \texttt{X->B} & La case contient la valeur \texttt{B} et est pointée par \texttt{X}\\
    \hline
    \texttt{@} & Indique l'addresse de la case\\
    \hline
    \texttt{[x]} & Représente une séquence de x fois le contenu de la parenthèse\\
  \end{tabular}
\end{center}
\setcounter{paragraph}{-1}

\vspace{1.5cm}

\paragraph{Entiers/Adresses - \texttt{000}}
Le choix a été pour éviter les comparaisons constantes de représenter tous les nombres en lua sous forme de doubles. Ainsi le type entier est en quelque sorte désuet au point de vue de l'utilisateur, cependant, certaine structures internes utilisent encore sa représentation.

Une valeur contenant ses trois LSB à 0 indique qu'elle ne pointe sur rien et donc que le GC peut l'ignorer. C'est pourquoi toutes les addresses sont des multiples de 8. Le compilateur s'assure d'aligner les adresses de retour et d'appelle, ainsi que de conserver la mémoire et la pile alignée. Ce faisant, on évite les accidents où le GC tenterait de copier une addresse de retour. La reconnaissance par le GC n'est pas la seule utilité de cet alignment. En effet, l'alignement général du stack et de la mémoire sur des multiples de 8 améliore la performance du cache, car aucun \textit{data chunk} ne risque d'être tronqué.
\newpage
\paragraph{Valeurs spéciales - \texttt{001}}
Les valeurs spéciales sont des constantes qui vont permettre au compilateur de d'obtenir de l'information sur certains object, au GC de reconnaître des cas particulier, ou simplement de représenter des constantes du langages. Voici la table de valeurs spéciales.
\begin{center}
  \begin{tabular}{r|c|p{12cm}}
    Nom & Valeur (hex) & Utilisation\\
    \hline
    FALSE & \texttt{0x00000001} & Représente la constante {\lstset{style=lua}\lstinline$false$}\\
    TRUE  & \texttt{0x00000009} & Représente la constante {\lstset{style=lua}\lstinline$true$}\\
    NIL   & \texttt{0x00000011} & Représente la constante {\lstset{style=lua}\lstinline$nil$}\\
    VOID  & \texttt{0x00000021} & Indique que la pile est vide et ne contient plus de valeur\\
    FRAH  & \texttt{0x00000081} & (For Ahead) Signale au GC qu'une boucle {\lstset{style=lua}\lstinline$for$} se trouve à cet endoroit sur la pile\\
    NEW   & \texttt{0x7FFFFFE1} & Signale au GC que le le tableau est en cours d'initialisation\\
    UNKN  & \texttt{0x7FFFFFF1} & (Unknown) Indique que la longueur d'un tableau n'est plus fiable et doit être recalculée\\
  \end{tabular}
\end{center}
\paragraph{Chaînes de caractères - \texttt{010}}
Les chaînes de caractères sont représentées par une case mémoire (8 bytes) contenant la taille de la séquence de byte qui suit (moins le caractère nul) sous la forme d'un entier non-étiqueté. La fin du string contient au moins un caractère nul, mais potentiellement plus pour être aligné avec la mémoire. Exemple:
\begin{center}
  \begin{tabular}{|c|}
    \hline
    \texttt{CASE VIDE@(Longueur + 8 mod 8)}\\
    \hline
    \texttt{[Longueur](Caractères : UT Bytes[])}\\
    \hline
    \texttt{String->+(Longueur : UT Int)}\\
    \hline
  \end{tabular}
  \hspace{2cm}
  \begin{tabular}{|c|}
    \hline
    \texttt{0000000073756E74}\\
    \hline
    \texttt{2072756F696E6F42}\\
    \hline
    \texttt{000000000000000C}\\
    \hline
  \end{tabular}
  \captionof{figure}{Exemple de la représentation en mémoire du string \protect\lstset{style=lua}\lstinline$"Bonjour tous"$}
\end{center}
\paragraph{Tables - \texttt{011}}
Les tables en Lua ont la propriété de pouvoir recevoir non seulement des nombre mais aussi des chaînes de caractères comme index. Bien que pratique d'un point de vu programmation, ceci rend leur implémentation plus complexe. Plusieurs option sont disponible pour permettre un tel usage. L'idée évidente serait d'empiler des paires \texttt{CLEF}/\texttt{VALEUR} une par dessus l'autre. Cependant cette technique est difficile car elle requière un grand espace mémoire contigue, l'alternative évidente est donc la liste chaînée. La liste chaînée pose cependant un inconvéniant majeur lors du parcours des valeurs de la table, si on veut accéder au 100\textsuperscript{ième} élément, il faut faire 101 accès mémoire! Considérant que Lua repose beaucoup sur l'utilisation des tables, et que la majoritée des tables sont initialisées à la bonne taille, une combinaison des deux options plus haute a été choisie.
\begin{center}
  \begin{tabular}{|c|}
    \hline
    \texttt{*(Tableau (TB) : UT Ptr)}\\
    \hline
    \texttt{*(Liste chaînée (LC) : UT Ptr)}\\
    \hline
    \texttt{Table->+(Longueur : UT Int)}\\
    \hline
  \end{tabular}
  \captionof{figure}{Représentation en mémoire d'une table}
\end{center}
NB: À l'intérieur de la table, toutes les valeurs sont non-étiquetées pour favoriser un traitement rapide de l'information.

 Chaque pointeur de la liste pointe sur le prochain élément jusqu'à ce qu'il n'y en aie plus, il vaut alors NIL. Si une table ne contient pas de liste chaînée, alors le pointeur de liste vaut NIL. Tous les index non entier ($\in\mathbb{R}\setminus\mathbb{Z}$) et les chaînes de caractères sont dirigés vers la liste chaînées.
\begin{center}
  \begin{tabular}{|c|}
    \hline
    \texttt{*(A : UT Ptr)}\\
    \hline
    \texttt{\#{}(VALEUR : T)}\\
    \hline
    \texttt{LC->\#{}(CLEF : T)}\\
    \hline
  \end{tabular}
  \begin{tabular}{|c|}
    \hline
    \texttt{*(B : UT Ptr)}\\
    \hline
    \texttt{\#{}(VALEUR : T)}\\
    \hline
    \texttt{A->\#{}(CLEF : T)}\\
    \hline
  \end{tabular}
  \begin{tabular}{|c|}
    \hline
    \texttt{*(C : UT Ptr)}\\
    \hline
    \texttt{\#{}(VALEUR : T)}\\
    \hline
    \texttt{B->\#{}(CLEF : T)}\\
    \hline
  \end{tabular}
  \begin{tabular}{|c|}
    \hline
    \texttt{NIL}\\
    \hline
    \texttt{\#{}(VALEUR : T)}\\
    \hline
    \texttt{C->\#{}(CLEF : T)}\\
    \hline
  \end{tabular}
  \captionof{figure}{Exemple d'une séquence de chaînage de la liste chaînée}
\end{center}

La partie tableau de la liste contient tous les index entiers. Si on tente d'accéder à un index trop élevé ou trop bas en mode «accès», NIL sera retourné. En mode «définition» le tableau sera copié à un autre endroit dans la mémoire et redimensionné pour accomoder le nouvel index. Le GC est responsable de redimensionner une table inutilement trop volumineuse.
\begin{center}
\begin{tabular}{|c|}
    \hline
    \texttt{CASE VIDE@(Capacité + 2)}\\
    \hline
    \texttt{[Capacité]NIL}\\
    \hline
    \texttt{+(Décalage : T Int)}\\
    \hline
    \texttt{TB->+(Capacité : T Int)}\\
    \hline
\end{tabular}
\captionof{figure}{Base du tableau d'index entiers}
\end{center}
Ceci donne la possibilité à l'usager de créer une perte de mémoire assez massive en définissant deux index extrêmement éloignés l'un de l'autre, cependant un tel comportement n'aurait pas vraiment de but autre que celui de faire planter le programe. Le bénéfice d'avoir un tableau directement indexable surpasse largement les inconvénients.

\paragraph{Objets - \texttt{100}}
Le type objet sert pour tous les types qui ne font pas partie des 7 principaux. En décalant à droite, on obtient un pointeur vers une case mémoire qui contient le type de l'objet, le compilateur doit donc faire une étape de plus pour obtenir le type, c'est pourquoi il décrit les objets moins fréquents. On considère que le type pointé en mémoire s'ajoute à 8 pour qu'il n'y ait pas de conflit avec les autres types existants. Par exemple, le type 4->0, est en fait le type 8 (le premier après Fonction (7)).
\setcounter{subparagraph}{-1}
\subparagraph{Fermetures - \texttt{1000}}
Les fermetures suivent le même principe que la liste chaînée des tables, mais elles sont chaînées dans l'autre sens de sorte que l'objet le plus récent est accessible le plus rapidement. Leur forme est la même que celle des maillons des tables, mais avec une case mémoire en plus pour le type. Vu qu'elles pointes toutes vers la même racine(ENV), ce sont les feuilles qui sont sauvegarder dans chaque fonction.

\begin{center}
\begin{tabular}{|c|}
    \hline
    \texttt{*(ENV : UT Ptr) | NIL}\\
    \hline
    \texttt{\#{}(VALEUR : T)}\\
    \hline
    \texttt{\#{}(CLEF : T)}\\
    \hline
    \texttt{Fermeture->+(Type : 0)}\\
    \hline
\end{tabular}
\captionof{figure}{Format d'une valeur «enfermée»}
\end{center}

\subparagraph{Fichiers - \texttt{1001}}
Les fichiers sont principalement gérés par du code C. L'objet fichier est une paire comprenant le type et soit un pointeur vers le fichier ouvert ({\lstset{style=lua}\lstinline$io.ftype(file) == "file"$}), ou la valeur NIL ({\lstset{style=lua}\lstinline$io.ftype(file) == "closed file"$}).
\begin{center}
\begin{tabular}{|c|}
    \hline
    \texttt{*(FILE : UT File Ptr) | NIL}\\
    \hline
    \texttt{File->+(Type : 1)}\\
    \hline
\end{tabular}
\captionof{figure}{Exemple de l'objet «file»}
\end{center}

\paragraph{Piles - \texttt{101}}
Les piles sont très importantes en Lua, une bonne partie du langage repose sur leur existance étant donné la possibilité de retourner un nombre indéfini de valeur. Les piles sont normalement volatiles, c'est-à-dire qu'elles ne sont pas sauvegardée en mémoire. Cependant, dans les fonctions variadiques la pile doit être sauvegardée c'est pourquoi le type 5 existe. Une fois désétiqueté, la valeur pointe sur une région de la mémoire ou de la pile (d'où le nom donné au type) qui peut être décrémentée successivement jusqu'à l'atteinte d'une valeur sentinelle (VOID).

\begin{center}
\begin{tabular}{|c|}
    \hline
    \texttt{Pile->\#{}(VALEUR : T)}\\
    \hline
    \texttt{...}\\
    \hline
    \texttt{VOID}\\
    \hline
\end{tabular}
\captionof{figure}{Format d'une pile}
\end{center}

\paragraph{Nombres à virgule flottante (doubles) - \texttt{110}}
Toutes les manipulation numérique effectuées par l'utilisateur se font sur les doubles. Ceci évide de devoir vérifier le type de chaque opérande avant chaque opération, ce qui rendrait le code lourd et beaucoup moins performant. Étant donné leur format, les double ne peuvent pas être décalés vers la gauche. On pourrait simplement masquer les trois LSB et ainsi perdre une certaine précision de la partie fractionnaire (3 bits/52). Mais cette option n'est pas idéale: en plus de perdre plus de 5\%{} de la précision, on se retrouve à devoir gérer des cas particulier (parfois les opérateur doivent utiliser \texttt{sarq} d'autre fois \texttt{xorq} pour désétiqueter, etc... Le plus simple sans compromettre la précision est tout simplement de gérer des pointeurs de double.

\begin{center}
\begin{tabular}{|c|}
    \hline
    \texttt{Double->+(VALEUR : UT Float)}\\
    \hline
\end{tabular}
\captionof{figure}{Représentation d'un double dans la mémoire}
\end{center}

\paragraph{Fonctions - \texttt{111}}
Les fonctions sont représentées par deux cases, l'une contient l'addresse d'appel, tandis que l'autre pointe sur l'environnement de fermeture. Avant d'appeler une fonction, le vieil environnement est sauvegardé sur la pile, et le nouvel environnement est chargé.

\begin{center}
\begin{tabular}{|c|}
    \hline
    \texttt{*(ENV : UT Ptr)}\\
    \hline
    \texttt{Fonction->*(FN : UT Fct Ptr)}\\
    \hline
\end{tabular}
\captionof{figure}{Représentation d'un double dans la mémoire}
\end{center}

\subsubsection{Fermetures}
\paragraph{Principe de fonctionnement}
L'environnement de fermeture fonctionne un peu comme un arbre. Au départ du programme, il pointe sur une case vide (NIL), la racine. Si une nouvelle fermeture est créée, elle s'ajoute et pointe sur l'ancien environnement, cela continue ainsi jusqu'à ce que la fonction se termine, à ce moment le vieil environement est restauré et si rien ne pointe sur la fonction terminée, la feuille est perdue. Dans l'exemple suivant, on assigne la fonction \texttt{Epsilon} à une variable globale, ce qui conserve une référence à son pointeur d'environnement. Les fonctions \texttt{Alpha} et \texttt{Gamma} qui ne sont pas assignée voient leur environnement disparaître à la fin de leur exécution.

\tikzset{>=latex}
\begin{center}
  \begin{tikzpicture}[sibling distance = 10em,
      every node/.style =
      {shape = rectangle, rounded corners, font=\ttfamily},
    alive/.style =
    {fill=green!50},
    dead/.style =
    {fill=red!50},
    edge from parent path={[<-](\tikzparentnode)--(\tikzchildnode)}]
  \node[alive]{NIL}
  child { node [dead] { Alpha }}
  child { node [alive] { Beta }
    child { node [alive]{ Delta }
      child { node [alive] { Epsilon }}
      child { node [dead] { Gamma }}}};
\end{tikzpicture}
\end{center}

\paragraph{Déroulement}
Une fois que le compilateur détecte qu'une valeur locale devra être utilisée depuis une autre fonction, il «enferme» cette valeur dans l'environnement de fermeture, une fois cela produit, toute les références ultérieures à cette valeur (même celles de son propre environnement) seront toutes passées par l'environnement de fermeture. C'est pourquoi dans l'exemple suivant, même si \texttt{a} est modifié après que la fonction \texttt{x} soit définie, le résultat est quand même 10.
\begin{lstlisting}[style=lua, caption={Fermeture},label=DescriptiveLabel]
test = function (a) 
   local x ; x = function (b) 
      return (a + b) 
   end 
   a = (a + 2) 
   return x 
end 

local x = test (3)
print (x (5)) 
\end{lstlisting}

\subsubsection{Assignation}
Le processus d'assignation de Lua est assez complexe malgré son apparente simplicité. Tout d'abord, les déclaration multiples ne sont pas faites variable par variable, comme en C. Elles sont plutôt faites par lot.
C'est parce qu'en lua, toutes les destinations sont évaluées avant les valeurs.
\begin{lstlisting}[style=lua, caption={Déclaration multiple},label=DescriptiveLabel]
  local x, y, z = 1, 2, 3
  x, y, z = y, y + x, x + y
\end{lstlisting}
On pourrait s'attendre à ce que \texttt{x} prenne la valeur de \texttt{y}, et ainsi donne la valeur de \texttt{2 * y} à \texttt{y}, et alors que \texttt{z} vaille \texttt{3 * y}. Or le résultat est le même que si toutes les assignation avaient été effectuées simultanéement.

Le compilateur utilise la pile pour sauvegarder la position des variables. Au fur et à mesure de l'évaluation, les adresses sont empilées, ensuite il calcule les résultats qui sont empilés eux aussi, puis une fonction de transfert fait corresondre chaque partie valeur de la pile à sa partie destination. Cette opération est beaucoup plus couteuse qu'une affection directe, mais elle est fidèle aux spécificités du langage\footnote{Cet algorithme de transfert pourrait être amélioré. Si on empiles les destinations à l'envers, ils suffit alors de "poper" la destination et y placer la valeur. L'idée derrière la fonction de transfert actuelle était de permettre que des fonctions retournant plusieurs arguments puissent être retournée au sein de la déclaration (et non seulement en dernière posisition)}.

\subsubsection{Boucles}
Le compilateur \luna{} prend en charge toute les boucle définie dans le langage Lua soient {\lstset{style=lua}\lstinline$for, for ... in, while, repeat .. until$}. Pour la plupart, leur implémentation est très simple. Dans le cas des boucles {\lstset{style=lua}\lstinline$while$} et {\lstset{style=lua}\lstinline$repeat .. until$} il s'agit d'un simple saut accompagné d'une comparaison. Dans le cas des boucles {\lstset{style=lua}\lstinline$for$} c'est un peu plus complexe.

\paragraph{Boucle \texttt{\textbf{for ... in}}}
Lorsque la boucle {\lstset{style=lua}\lstinline$for .. in$} est appelée, le compilateur réserve 3 espace sur la pile d'exécution où il placera respectivement la fonction d'itération, puis les deux paramètres d'initialisation. La pile d'exécution ressemble alors à ceci:
\begin{center}
  \begin{tabular}{|c|}
    \hline
    \texttt{...}\\
    \hline
    \texttt{*(Itérateur : T Fct Ptr)}\\
    \hline
    \texttt{\#{}(P1 : T)}\\
    \hline
    \texttt{\#{}(P2 : T)}\\
    \hline
    \texttt{[n]\#{}(Variables d'itération : T)}\\
    \hline
  \end{tabular}
\captionof{figure}{Bloc d'activation de la boucle {\protect\lstset{style=lua}\lstinline$for .. in$}}
\end{center}
Les variables d'itérations sont définies par l'utilisateur pour prendre la valeur de retour (ou les valeurs) de la fonction d'itération.

\paragraph{Boucle \texttt{\textbf{for}}}
La boucle {\lstset{style=lua}\lstinline$for$} quand à elle est optimisée pour pouvoir «tourner» le plus vite possible, on veut donc stocker les doubles directement pour qu'ils soient facilement accessible et manipulable. Cependant, des double non-étiquetés sur la pile sont dangereux pour le GC, c'est pour quoi il est averti de la présence du {\lstset{style=lua}\lstinline$for$} grâce au FRAH.
\begin{center}
  \begin{tabular}{|c|}
    \hline
    \texttt{...}\\
    \hline
    \texttt{FRAH}\\
    \hline
    \texttt{*(Référence : T Float Ptr)}\\
    \hline
    \texttt{+(Itérateur : UT Float)}\\
    \hline
    \texttt{+(Arrêt : UT Float)}\\
    \hline
    \texttt{+(Incrémentateur : UT Float)}\\
    \hline
  \end{tabular}
\captionof{figure}{Bloc d'activation de la boucle {\protect\lstset{style=lua}\lstinline$for$}}
\end{center}

Toutes les variables d'itération ne sont pas étiquetées sauf la variable de référence. C'est pour pouvoir référer à l'itérateur dans le code. En Lua, il est impossible de changer la valeur de l'itérateur dans une boucle {\lstset{style=lua}\lstinline$for$}, un nouveau double est donc synthétisé à chaque tour depuis l'itérateur et placé dans la case de référence.

\subsubsection{Fonctions variadiques}
\paragraph{Paramètres manquants}
En Lua il est acceptable d'appeler une fonction avec le mauvais nombre de paramètres. Cette situation est problématique car \luna{} respecte les standard d'appel de C, langage ou cette pratique est totalement interdite. Le problème vient du fait que les 6 premier paramètres sont passés par les registres, mais les paramètres suivant sont sur la pile. Cela ne pose pas problème si il y a trop de paramètres, mais en appelant une fonction qui requière au dessus de 6 paramètres, si on en omet un ou plus, les éléments de la fonction vont tenter de référer à une partie de la pile d'exécution qui ne leur appartient pas. C'est pourquoi avant chaque fonction, la routine \texttt{\_{}nil\_{}fill} est appelée. Cette routine va modifier la pile de sorte à ce que les arguments manquants soient référençables (et contiennent la valeur NIL). L'exemple ci-dessous se produirait si on appelait une fonction de 8 arguments avec 6 arguments ou moins:

\begin{center}
  \begin{tabular}{|c|}
    \hline
    \texttt{\#{}(PREVIOUS FRAME)}\\
    \hline
    \texttt{*(RETURN ADDRESS : T Address)}\\
    \hline
    \texttt{*(BASE POINTER : T Address)}\\
    \hline
  \end{tabular}
  \hspace{1cm} {\Huge{$\,\to\,$}} \hspace{1cm}
  \begin{tabular}{|c|}
    \hline
    \texttt{\#{}(PREVIOUS FRAME)}\\
    \hline
    \texttt{NIL}\\
    \hline
    \texttt{NIL}\\
    \hline
    \texttt{*(RETURN ADDRESS : T Address)}\\
    \hline
    \texttt{*(BASE POINTER : T Address)}\\
    \hline
  \end{tabular}
\captionof{figure}{Effet de \texttt{\_{}nil\_{}fill} sur la pile}
\end{center}

\paragraph{Paramètres variables}
Si le paramètre variable est inclu, la fonction va ensuite appeler la routine \texttt{\_{}var\_{}args}. Cette routine a pour bu de récupérer les paramètres en trop et de les placer dans une pile à laquelle le programme peut avoir accès tout au long de la fonction.


\subsubsection{Appels terminaux}
Le compilateur optimise l'appel terminal en conservant le même \textit{frame} pour tous les appels terminaux. En raison de l'imprévisibilité de la taille du \textit{frame} dans une fonction variadique, celles-ci ne peuvent pas bénéficier de l'optimisation terminale.

\subsubsection{Librairies}
Le compilateur \luna{} a accès à une série de librairies où sont définies des variables et fonctions utiles. Quand les librairies sont construites, le compilateur inscrit les variables disponibles ainsi que leur provenance dans un fichier «.lib». Par la suite, chaque fois qu'il compile un fichier, il vérifie si celui-ci accède à une des variables des librairies. Si c'est le cas, il l'ajoute à la liste d'inclusion. De cette manière l'inclusion est automatique et l'usager n'a pas à se tracasser. De plus, le fichier exécutable produit ne contient pas de code mort qui augmenterait inutilement sa taille.

\paragraph{arg}
La librairie arg est toute petite, elle permet à un programme Lua d'accéder aux arguments de la ligne de commande et défini ces arguments dans la table \texttt{arg}.

\paragraph{io}
Cette librairie est presque complèment implémentée, elle décrit la table \texttt{io}. Cette table définie une série de fonction qui permettent entre autre la lecture et l'écriture de fichier, la redirection du \texttt{stdin} ou \texttt{stdout}.

\paragraph{lua}
Cette librairie est la librairie «de base», presque tout les programmes en ont besoin. C'est elle qui contient les référence à \texttt{print}, \texttt{tostring}, \texttt{tonumber}, etc...

\paragraph{os}
La table \texttt{os}, définie dans cette libraire contient des fonctions relative au système d'exploitation. Elles permettent par exemple d'exécuter un programme, ou bien de quitter l'exécution abruptement.

\paragraph{string}
La librairie \texttt{string}, contient toutes les fonctions relatives aux chaînes de caractères, comme le formattage, la recherche, ou le prélèvement.

\paragraph{table}
Finalement, \texttt{table} est une librairie qui contient des utilitées pour faciliter le traitement des tables, comme une fonction de bouclage ou de concaténation.

\paragraph{}
\textbf{\color{red}***Sans compter la libraire \texttt{io}, toutes les librairies sont à un stage très jeune de leur écriture.}

\newpage
\subsection{Collection de déchets}
Le compilateur inclu dans le code son collecteur de déchet, ou \textit{Garbage Collector} (écrit en C). Le but du GC est de réorganiser et compacter la mémoire pour faire de la place aux allocation ultérieures. À chaque fois que le programme effectue une opération qui remplie potentiellement la mémoire (transfert, appel de fonction, retour de fonction, définition de variable, définition de table, etc.) il appelle le GC. Celui-ci vérifie si la mémoire est encore en dessous du seuil acceptable, définie par défaut à 75\%{}. Si c'est le cas, il retourne immédiatement à l'exécution, sinon, il commence sont travail. Suite à la relocalisation de la mémoire le GC va évaluer si le programme utilise trop d'espace (la nouvelle plage mémoire se situe en dessous de 25\%{} de la mémoire allouée) où pas assez (la nouvelle plage mémoire est toujours au dessus de 75\%{} même après la compaction. Si c'est le cas, il va ajuster la taille de la mémoire en conséquence (la diviser par deux, ou la doubler respectivement). De cette manière si un programme à besoin d'une quantité immense de mémoire pour un court laps de temps, il se la verra allouée et le programme ne plantera pas, mais lorsque sa demande va diminuer, le GC diminuera à sont tour la taille de la mémoire afin d'alléger le stresse que le programme impose à la machine.

\subsubsection{Type de GC}
Au départ, \luna{} était supposé avoir un GC Stop \&{} Copy standard. Cependant, afin d'optimiser les opération interne sur les structures (qui sont nombreuse, particulièrement dans le cas des tableaux) les pointeurs internes ne sont pas étiquetés. Ceci signifie que le GC Stop \&{} Copy ne serait pas en mesure de détecter les fragments de structures internes nouvellement copiées dans la mémoire (à moins que celles-ci soient pourvue d'un tag lors de la copie). Pour faire plus simple, le programme fait tout simplement explorer récursivement toute les structures qu'il rencontre au moment de la copie. Cela occupe plus de mémoire lors du processus de nettoyage, mais permet de sauver beaucoup d'étape pendant l'exécution normale du programme.

\subsubsection{Performance du GC}
La performance du GC n'est pas optimale, premièrement il y a le problème de mémoire décrit plus haut. Si on a une liste chaînée de 100 valeurs, ce qui est très plausible, le GC devra descendre récursivement jusqu'à la 100ième valeur puis retourner tout en haut. Non seulement le trajet est deux fois plus long mais des listes chaînées de grande taille sont suceptibles de causer un \textit{Stack Overflow}. Changer le GC pour un GC Stop \&{} Copy ordinaire serait envisageable, et probablement relativement facile étant donné que toute les structures de copies sont en place.

Un autre désavantage (qui ne peut être corrigée par une architecture de GC plus efficace) provient de la manière dont sont traitées les assignations en Lua. Puisque les destinations sont d'abord empilées \textit{puis} les valeurs sont transférées, on se retrouve avec une série de destinations sur la pile qui doivent être modifiées. Or les objets sur lesquels celles-ci pointent ne sont pas distingable (peut-être un index de l'environnement de fermeture, peut-être un index de la table globale, peut-être une case sur la pile). Il faut donc attendre que toute la mémoire vivante soit copiée avant de pouvoir regarder le tag de «c\oe{}ur brisé» et faire l'ajustement nécessaire.

\subsubsection{Bugs}
Le GC fonctionne bien avec toutes les fonctions natives du compilateur, mais il persite un bug non résolu qui se produit lorsque le GC est appelé avant qu'une fonction C relative aux fichiers soit appelée (popen, fopen).

\newpage
\section{Préprocesseur}
Le but du préprocesseur est de standardiser tous les fichiers de code de manière à ce que le compilateur puisse éventuellement traiter des fichiers suivant un certain patron plus strict de formattage. C'est important puisque rien ne garanti que tous les programmeurs ont la même éthique d'écriture. Dans ce cas-ci particulièrement, le préprocesseur est très utile car le langage Lua a une syntaxe plus permissive que la plupart des autres langages impératifs. Alors que beaucoup exigent le fameux «;» à la fin de chaque ligne, en Lua il n'est nécessaire que pour séparter deux instructions consécutives ambiguës. Il existe également plusieurs forme équivalentes pour exprimer la même chose, ce qui pourrait devenir compliquer pour un compilateur. Finalement, les expressions ne sont pas forcément correctement parenthésées au moment de la compilation, le préprocesseur permet de compléter les parenthèse manquante.

\subsection{Fonctions du préprocesseur}
Afin de faciliter au maximum le travail du compilateur, le préprocesseur accompli plusieurs tâches diverses, allant du formattage à la précompilation. Les voici:

\subsubsection{Détection d'erreur}
Il est facile de faire des erreurs en programant, mais pas toujours de les trouver. Le simple fait de chercher une parenthèse mal fermée peut représenter une perte de temps importante. Par exemple dans le segment de code suivant, on voit qu'une parenthèse fermante manque.
\lstset{style = lua}
\begin{lstlisting}[caption={Mauvais parenthèsage},label=DescriptiveLabel]
  local x = print(test(i)
\end{lstlisting}

Un des rôles du préprocesseur va être d'avertir l'usager de son erreur. Si on tente d'exécuter luna sur le code suivant, on obtient ceci:
\lstset{style = out}
\begin{lstlisting}
FILE: tmp.lua
Error at line 1: Parenthesis mismatch.
local x = print(test(i)
               ^
\end{lstlisting}
Comme on peut le voir, le programme indique une erreur en pointant sur la parenthèse qui n'a pas été fermée. Ce genre d'aide est très utile à l'usager, et lui permet de sauver du temps. De plus en détectant les erreurs plus haut dans le processus de compilation et en les supportant, on réduit le risque d'erreur fatale plus tard dans le processus de compilation, où un code incorrect est très difficile à prévoir et peut facilement faire planter le compilateur.

\subsubsection{Effacement des commentaires}
Une fonction bête mais essentielle du préprocesseur est d'effacer les commentaire laissés par l'usager. Cette supression permettra au compilateur de lire le fichier Lua sans avoir à se préocupper de fragments de code inutiles. Un fragment de code comme celui-ci:
\lstset{style = lua}
\begin{lstlisting}[caption={Commentaires multiples},label=DescriptiveLabel]
--Bonjour
local x = "tout" .. --[[le]] "monde"
--[[Il
   fait
   beau]]
local y = "dehors"
\end{lstlisting}

\newpage
devient en fait beaucoup plus simple:
\begin{lstlisting}[belowcaptionskip = -1\baselineskip]

local x = ("tout" .. monde) 
local y = "dehors"
\end{lstlisting}

\subsubsection{Indentation}
Même si le but ici n'était pas d'écrire un éditeur de texte pour le langage, l'idée de faire une fonction d'indentation semblait très raisonnable. En effet, que ce soit par presse ou par paresse, les programmeurs vont occasionnellement écrire du code mal formaté et il est alors très pratique de pouvoir l'indexer automatiquement. Le préprocesseur va également conserver les choix personnel du programmeur quand à ses «saut de ligne», de sorte qu'un code comme celui-ci:
\begin{lstlisting}[caption={Code mal formaté},label=DescriptiveLabel]
if
   y==x and
            b==3 and
   c==4
then
if y==2 then
 print("y=2")
   elseif
 x==3 then
   print("x=3")
   else
  print(c)
   end
end
\end{lstlisting}
va être transformé par le préprocesseur pour produire un code bien indenté:
\begin{lstlisting}[belowcaptionskip = -1\baselineskip]
if 
   (((y == x) and 
   (b == 3)) and 
   (c == 4)) 
then 
   if (y == 2) then 
      print ("y=2") 
   else if 
         (x == 3) then 
         print ("x=3") 
      else 
         print (c) 
      end 
   end 
end 
\end{lstlisting}

Bien évidemment, une telle fonction requière une certaine quantitée de ressource en comparaison avec une autre qui n'aurait pas autant d'éléments à prendre en charge. Il faut cependant réaliser qu'elle permet de lire des nombres et des opérateurs collés et ensuite de les décoller. Un des avantages immense de cette partie du processus sera évidente ultérieurement, alors que l'écriture d'une fonction de \textit{parsing} deviendra triviale.

\newpage
\subsubsection{Parenthèsage}
Comme dans tous les langages à notation infixe, le compilateur doit s'assurer d'avoir un parenthèsage complet avant d'évaluer une expression.
\begin{lstlisting}[caption={Parenthèsage incomplet},label=DescriptiveLabel]
  local x=3+4-2-3*-2^-2+4/5%8
\end{lstlisting}

Une expression du genre est plutôt difficile à évaluer, c'est pourquoi le préprocesseur va former les expressions une à une en suivant l'ordre de priorité prescrit par le langage. Le résultat est le suivant:
\begin{lstlisting}[belowcaptionskip = -1\baselineskip]
local x = ((((3 + 4) - 2) - (3 * (- (2 ^ (- 2))))) + ((4 / 5) % 8))
\end{lstlisting}

On constate immédiatement une lisibilité accrue; il en va de même pour le compilateur. Pour les étapes suivante on sait qu'il y a 1 ou 2 opérande par opérateur, il n'y aura donc que deux cas à gérer.
\subsubsection{Précompilation}
La ligne obtenue dans la précédente section est en réalité obtenue en exécutant \texttt{./luna -npc -s tmp.lua}, c'est à dire en spécifiant au compilateur qu'on ne veut pas précompiler. Sans la \textit{switch} \texttt{-npc}, le résultat est en fait le suivant:
\begin{lstlisting}[belowcaptionskip = -1\baselineskip]
local x = 6.55
\end{lstlisting}


Le principe est d'éviter au programme compilé des calculs facilement évitable. Au fur et à mesure que les parenthèses sont formées, le préprocesseur vérifie si celles-ci sont possible à évaluer (qu'elles ne contiennes pas de variable). Si l'évaluation est réussie, il remplace la parenthèse par le résultat de sont évaluation.

\subsubsection{Standardisation}
L'objectif final, et non le moindre, du préprocesseur est de limiter le langage à un sous emsemble sur lequel il le compilateur pourra compter. Le langage Lua offre de nombreuses contraction et macros que le préprocesseur transforme en version plus basique.
\begin{lstlisting}[caption={Utilisation des contractions et des macros},label=DescriptiveLabel]
tmp = { allo = 9 }

function tmp.test(a)
   return a.x:sub(i, i)
end

local function loc(n)
   return n + 1
end
\end{lstlisting}

Comme on peut le voir dans l'exemple ci-haut, il est possible de référer aux indices textuels d'une table en utilisant «\texttt{table.index}»; cela reviens exactement au même qu'écrire «\texttt{table ["index"]}». La seconde forme sera priorisé dans le texte final puisqu'elle est standard et fonctionne avec tous les types d'index. On remarque aussi qu'il est possible de déclarer des fonction sans utiliser explicitement l'opérateur de déclaration «=». Cette déclaration en ligne est pratique car agréable à l'oeil, mais ce n'est pas un format conventionnel que le compilateur pourra traiter, il faut donc aussi les développer:

\newpage
\begin{lstlisting}[belowcaptionskip = -1\baselineskip]
tmp = { allo = 9 } 

tmp ["test"] = function (a) 
   return a : sub (i , i) 
end 
local loc ; loc = function (n) 
   return (n + 1) 
end 
\end{lstlisting}

Lors de l'expansion de la déclaration d'une fonction locale, un point-virgule s'ajoute au code\footnote{https://www.lua.org/manual/5.3/manual.html, section 3.4.11}. Ce point-virgule est en fait essentiel car en Lua les assignations sont faites après l'évaluation de toute les valeurs. Sans le point-virgule, lorsque la fonction \texttt{loc} serait évaluée, le terme «loc» n'existerait pas encore et elle ne pourrait pas s'y référer. Par contre le deux-point dans l'expression «\texttt{a : sub (i , i)}» n'est pas transformé. Ce choix a été fait pour des raison d'optimisation. Cette optimisation est particulièrement visible dans les expressions de la forme suivante:
\begin{lstlisting}[caption={Développement sous-optimal},label=DescriptiveLabel]
table.x.y.z:sub(1, 1) ==
	table ["x"] ["y"] ["z"] ["sub"] (table ["x"] ["y"] ["z"] , 1 , 1)
\end{lstlisting}

On peut voir que développer le «\texttt{:}» est en fait sous-optimal, dans le second cas, la table «\texttt{table}» devra être indexée deux fois, une fois à 4 niveau de profondeur, la seconde à 3. En conservant le «\texttt{:}», on peut implémenter une manière beaucoup plus efficace de réaliser cette opération en rajoutant des instructions au compilateur.

\newpage
\subsection{Mécanisme}
Le préprocesseur a de nombreuses fonctions à remplir. Ces fonctions sont pour la plupart cependant simplement destinée à faciliter la tâche des compilateurs ultérieurement et à favoriser les chances de succès, c'est-à-dire qu'aucune d'entre elles ne fait réellement partie du processus de compilation. Le tout semblant un peu superflu, on souhaite réduire au maximum le temps que le programme prend pour effectuer cette tâche. La première version du préprocesseur était très simple mais demandait le lire le texte à plusieurs reprise en modifiant une chose à chaque fois. La version présentement utilisée ne fait qu'un seul passage, et exécute chacune de ces fonctions simultanément.

\subsubsection{Fonction de \textit{parsing}}
La reconnaissance de texte en Lua n'est pas la chose la plus évidente. Il faut donc un fonction robuste capable de différencier tous les termes réservés du langage de ceux utilisable pour les variables, de différencier une variable d'un opérateur même s'il n'y a pas d'espace entre les deux, d'un chiffre et ainsi de suite... Pour Luna, cette fonction s'appelle \texttt{nexttoken}. Pour un endroit quelconque dans le texte, lorsqu'appelée cette fonction retournera le prochain élément du langage, déjà formaté dans le cas d'un string, ainsi que la nouvelle position du lecteur.
\begin{lstlisting}[caption={Lecture d'un string},label=DescriptiveLabel]
tmp = %*\color{red}°*)[[Paul profitait du soleil.
	- "Il n'y avait pas beaucoup de monde sur la plage aujourd'hui", pensait-il.]]
\end{lstlisting}

Dans l'exemple ci-haut position du lecteur est donné par «{\color{red}°}». Suite à l'appel de la fonction \texttt{nexttoken} le programe se retrouve dans cet état:
\begin{lstlisting}[belowcaptionskip = -1\baselineskip]
tmp = "Paul profitait du soleil.\n\t- \"Il n'y avait pas beaucoup de monde sur la plage aujourd'hui\", pensait-il." %*\color{red}°*)
\end{lstlisting}

Le nouveau \textit{string} produit utilise la notation classique avec les guillements anglais, prenant soin de bien protéger les caractère spéciaux, comme le \textit{newline} et le \textit{tab} ainsi que les guillements présents avec la barre oblique inversée.

\subsubsection{Lecture de ligne}
À chaque ligne la fonction \texttt{nexttoken} est appelée jusqu'à ce que lecteur rencontre le caractère \textit{newline}, atteigne un délimitateur d'environnement, ou atteigne la fin du fichier. Cependant, si la ligne se termine par un terme qui en nécessite un autre (comme un opérateur) la ligne ne sera pas considérée comme terminée. Au fur et à mesure que les mots sont lus, ils sont ajouter à une table d'expressions. C'est cette table qui sera utilisée pour le parenthèsage.

\paragraph{Conversion de la macro «.»}
La représentation sous forme de table est le moment idéal pour éliminer les index de table qui utilisent le point. Le préprocesseur peut facilement passer à travers les éléments, lorsqu'il détecte un point, il supprime cet élément ainsi que le \texttt{précédent} de la table et remplace le \texttt{suivant} par \texttt{précédent ["suivant"]}.

\newpage
\paragraph{Parenthèsage} 
Le système de parenthèsage est plutôt simple, il est réalisé par les fonction \texttt{comb1} et \texttt{comb2}, depuis la fonction \texttt{scan}. Essentiellement, \texttt{scan} les appelles successivement avec une liste d'opérateur à associer (dans l'ordre de priorité du langage). La fonction de combinaison parcours la table, et lorsqu'elle trouve un opérateur de ses paramètres, elle va tout d'abord tenter de résoudre le calcul posé par cet opérateur grâce à \texttt{trysolve}. Dans le cas d'un échec elle va retourner un string qui correspond au deux opérandes et l'opérateur entre parenthèses.
\begin{lstlisting}[caption={Trace partielle d'exécution de la fonction scan},label=DescriptiveLabel]
expr = { "a", "+", "b", "*", "c", "(", "3", "+", "(", "-", "2", ")", ")"}
scan(expr):
> scan { "3", "+", "(", "-", "2", ")" }
   > scan { "-", "2" }
      -- niveau unaire
      > comb1 { {"-" , "2"}, "not", "-", "~", "#"} 
         > trysolve ("-", "2", nil)
         << "-2"
      << "-2"
   << "(-2)"
      -- niveau additif
      > comb2 { {"+", "(-2)"}, "3", "+", "-") 
         > trysolve ("+", "(-2)", "3")
         << "1"
      << "1"
<< "(1)"
   -- niveau multiplicatif
   > comb2 { {"a", "+", "b", "*", "c (1)"}, "*", "/", "\\", "%" }
   -- niveau additif
   > comb2 { {"a", "+", "(b * c (1))"}, "+", "-")
<< "(a + (b * c (1)))"
\end{lstlisting}

\texttt{scan} s'exécute récursivement lorsque des parenthèses sont déja présentes. Avant d'appeler les fonctions de combinaison, \texttt{scan} s'assure également de combiner les fonctions avec leurs paramètres. Il est impératif que cette fonction produise du code fidèle (sans parenthèse superflue), car en lua les parenthèse de trop sont utilisée pour la troncation de la séquence de retour, ainsi «\texttt{(var)}» n'a pas la même signification que «\texttt{var}».

\subsubsection{Préprocesseur et parcours des environnements}
Afin de préparer le code, le préprocesseur appelle la fonction de lecture de ligne en boucle. Mais parfois celle-ci tomber sur un délimitateur d'environnement. Les fonctions décrites précédemment sont toutes à l'affût des délimitateurs, si l'une d'entre elles détecte un mot réservé qui débute un environnement, le préprocesseur s'appelera lui-même en augmentant de 1 le paramètre d'indexation. Le préprocesseur descend ainsi récursivement dans les environnements s'assurant par le fait même d'une bonne indexation et d'une structure cohérente. Ce faisant, il transforme également les {\lstset{style=lua}\lstinline$elseif$} en {\lstset{style=lua}\lstinline$else if$} pour que le code soit plus facile à traiter.

\newpage
\subsection{Récapitulation}
Le préprocesseur est utile pour de nombreuse raison, la principale étant de produire du code lisible pour le compilateur. Cependant il est également pratique pour nettoyer un code mal indenté, détecter les erreurs de l'utilisateur et précompiler le code pour rendre celui-ci le plus cours possible.

Fichier avant traitement:
\begin{lstlisting}[caption={Récapitulatif des fonctionnalitées},label=DescriptiveLabel]
function add(v1, v2)
--[[ 
      Ceci est un exemple de fichier qui 
      sera "preprocessed", similaire au code
      du compilateur-ir
   ]]
   local function mem(v)
      if true and v then
	 v = "(" .. "%rbx" .. ")"
      end
   end
   return "\tmovq\t" .. v1 .. ", %rax\n" ..
      "\tmovq\t" .. v2 .. ", %rdx\n" .. -- v2 dans %rdx
      "\addq\t" .. "%rax" .. ", " .. "%rdx" .. "\n"
end
\end{lstlisting}

Fichier après traitement:
\begin{lstlisting}[belowcaptionskip = -1\baselineskip]
add = function (v1 , v2) 
   local mem ; mem = function (v) 
      if v then 
         v = "(%rbx)" 
      end 
   end 
   return ("\tmovq\t" .. (v1 .. (", %rax\n" .. 
      ("\tmovq\t" .. (v2 .. (", %rdx\n" .. 
      "\addq\t%rax, %rdx\n")))))) 
end 
\end{lstlisting}

\newpage
\section{Compilateur}
\paragraph{Jeu d'instruction IR}
\label{par:instructions}
\begin{longtable}{p{1.3cm} r p{12cm}}
  {\lstinline$a + b$} & \textbf{add} & Effectue l'addition de deux doubles.\\
  {\lstinline$x and y$} & \textbf{and} & Si \texttt{x} n'est pas {\lstset{style=lua}\lstinline$false$} ou {\lstset{style=lua}\lstinline$nil$}, poursuit l'exécution à \texttt{y}, sinon retourne la valeur de \texttt{x}, si l'exécution est poursuivie à \texttt{y}, retourne la valeur de \texttt{y}\\
  {\lstset{style=lua}\lstinline${, y}$} & \textbf{append} & Ajoute un élément à la table en cours de définition au prochain index vide après sa conclusion.\\
  {\lstinline$m & n$} & \textbf{band} & Effectue un 'AND' bit à bit entre \texttt{m} et \texttt{n}.\\
  {\lstinline$p === q$} & \textbf{beq} & Compare les pointeurs, retourne {\lstset{style=lua}\lstinline$true$} si ils pointent vers le même objet.\\
  {\lstinline$~n$} & \textbf{binv} & Inverse les bits du nombre entier \texttt{n}.\\
  {\lstinline$p != q$} & \textbf{bneq} & Compare les pointeurs, retourne {\lstset{style=lua}\lstinline$false$} si ils pointent vers le même objet.\\
  {\lstinline$m | n$} & \textbf{bor} & Effectue un 'OR' bit à bit entre \texttt{m} et \texttt{n}.\\
  {\lstinline$m << n$} & \textbf{bsal/bshl} &  Décale l'entier \texttt{m} de \texttt{n} bits vers la gauche (décalage arithmétique ou logique).\\
  {\lstinline$m >> n$} & \textbf{bsar} & Décale l'entier \texttt{m} de \texttt{n} bits vers la droite. Si le MSB est 1, tous les bits décalés depuis le MSB sont mis à 1 (décalage arithmétique, conserve la négativité).\\
  {\lstinline$m >>> n$} & \textbf{bshr} & Décale \texttt{m} de \texttt{n} bits vers la droite. Les bits décalés depuis le MSB sont 0 (décalage logique, ne conserve pas la négativité).\\
  {\lstinline$m ~ n$} \newline {\lstinline$m ^^ n$} & \textbf{bxor} & Effectue un 'XOR' bit à bit entre \texttt{m} et \texttt{n}.\\
   & \textbf{call} & Procède à l'appel de la fonction préparée dans \texttt{\textbf{params}} ou \texttt{\textbf{fparams}}.\\
  {\lstinline$x = y$} & \textbf{chg} & Effectue le transfert de la valeur de \texttt{y} à l'addresse de \texttt{x}, pour les variables globales ou déjà définie.\\
  {\lstinline$s .. t$} & \textbf{con} & Effectue la concaténation de la chaîne de caractère \texttt{s} avec la chaîne de caractère \texttt{t}.\\
   & \textbf{clo} & Réfère à un élément de l'environnement de fermeture.\\
  {\lstinline$a / b$} & \textbf{div} & Effectue la division de deux doubles.\\
  {\lstset{style=lua}\lstinline$do$} & \textbf{do} & Commence l'environnement {\lstset{style=lua}\lstinline$do$}.\\
  {\lstset{style=lua}\lstinline$}$} & \textbf{done} & Conclu la définition d'une table après \texttt{\textbf{init}}.\\
  {\lstset{style=lua}\lstinline$else$} & \textbf{else} & Marque le début de la seconde branche du {\lstset{style=lua}\lstinline$if$}.\\
   & \textbf{encl} & «Enferme» une valeur dans l'environnement de fermeture.\\
  {\lstset{style=lua}\lstinline$end$} & \textbf{end} & Termine l'environnement {\lstset{style=lua}\lstinline$do$}.\\
  {\lstinline$x == y$} & \textbf{eq} & Effectue la comparaison de \texttt{x} avec \texttt{y}, si \texttt{x} et \texttt{y} sont des string ou des doubles, cette comparaison compare l'objet pointé et non les pointeurs. Retourne {\lstset{style=lua}\lstinline$true$} si les valeurs sont les mêmes, {\lstset{style=lua}\lstinline$false$} sinon.\\
  & \textbf{exit} & Termine le programme.\\
  {\lstset{style=lua}\lstinline$function$} & \textbf{fct} & Marque le début d'une fonction.\\
  {\lstset{style=lua}\lstinline$end$} & \textbf{fend} & Marque la fin d'une fonction.\\
  {\lstset{style=lua}\lstinline$do$} & \textbf{fido} & Marque l'entrée dans la boucle {\lstset{style=lua}\lstinline$for ... in$}.\\
  {\lstset{style=lua}\lstinline$end$} & \textbf{fiend} & Marque la fin de la boucle {\lstset{style=lua}\lstinline$for ... in$}.\\
  {\lstset{style=lua}\lstinline$x:y$} & \textbf{findex} & Indexe un objet, en conservant celui-ci sur la pile pour qu'il soit utilisé par \texttt{\textbf{fparams}}.\\
   & \textbf{fname} & Spécifie le nom de la fonction.\\
  {\lstset{style=lua}\lstinline$for$} & \textbf{for} & Marque le début de la boucle {\lstset{style=lua}\lstinline$for$}.\\
  {\lstset{style=lua}\lstinline$for ... in$} & \textbf{forin} & Marque le début de la boucle {\lstset{style=lua}\lstinline$for ... in$}.\\
  {\lstset{style=lua}\lstinline$f:y(x)$} & \textbf{fparams} & Suite à \texttt{\textbf{findex}}, appelle une fonction à la notation contractée. \\
  {\lstset{style=lua}\lstinline$do$} & \textbf{frdo} & Marque l'entrée dans la boucle {\lstset{style=lua}\lstinline$for$}.\\
  & \textbf{free} & Libère les variables locales du context courrant.\\
  {\lstset{style=lua}\lstinline$end$} & \textbf{frend} & Marque la fin de la boucle {\lstset{style=lua}\lstinline$for$}.\\
  {\lstset{style=lua}\lstinline$x$} & \textbf{gbl} & Accède ou définie une variable globale.\\
  {\lstinline$x > y$} & \textbf{gt} & Effectue la comparaison de \texttt{x} avec \texttt{y}, si \texttt{x} et \texttt{y} sont des string ou des doubles, cette comparaison compare l'objet pointé et non les pointeurs. Retourne {\lstset{style=lua}\lstinline$true$} la première valeur est plus grande que la seconde, {\lstset{style=lua}\lstinline$false$} sinon. Dans le cas des string, on utilise l'ordre lexicographique.\\
  {\lstinline$x >= y$} & \textbf{gte} & Effectue la comparaison de \texttt{x} avec \texttt{y}, si \texttt{x} et \texttt{y} sont des string ou des doubles, cette comparaison compare l'objet pointé et non les pointeurs. Retourne {\lstset{style=lua}\lstinline$true$} la première valeur est plus grande ou égale à la seconde, {\lstset{style=lua}\lstinline$false$} sinon. Dans le cas des string, on utilise l'ordre lexicographique.\\
  {\lstinline$a \ b$} \newline {\lstinline$a // b$} & \textbf{idiv} & Effectue la division entière de \texttt{a} par \texttt{b}.\\
  {\lstset{style=lua}\lstinline$end$} & \textbf{iend} & Termine l'environnement {\lstset{style=lua}\lstinline$if$}.\\
  {\lstset{style=lua}\lstinline$if$} & \textbf{if} & Marque le début de l'environnement {\lstset{style=lua}\lstinline$if$}.\\
  {\lstset{style=lua}\lstinline$x[y]$} & \textbf{index} & Index une table avec la valeur spécifiée.\\
  {\lstset{style=lua}\lstinline${$} & \textbf{init} & Débute la définition d'une table.\\
  {\lstinline$#x$} & \textbf{len} & Si \texttt{x} est une table ou un string, retourne sa longueur. La longueur d'une table est considérée comme le nombre d'éléments non-nuls entre l'index 1 et le premier élément valant {\lstset{style=lua}\lstinline$nil$}.\\
  {\lstinline$x < y$} & \textbf{lt} & Effectue la comparaison de \texttt{x} avec \texttt{y}, si \texttt{x} et \texttt{y} sont des string ou des doubles, cette comparaison compare l'objet pointé et non les pointeurs. Retourne {\lstset{style=lua}\lstinline$true$} la première valeur est plus petite que la seconde, {\lstset{style=lua}\lstinline$false$} sinon. Dans le cas des string, on utilise l'ordre lexicographique.\\
  {\lstinline$x <= y$} & \textbf{lte} & Effectue la comparaison de \texttt{x} avec \texttt{y}, si \texttt{x} et \texttt{y} sont des string ou des doubles, cette comparaison compare l'objet pointé et non les pointeurs. Retourne {\lstset{style=lua}\lstinline$true$} la première valeur est plus petite ou égale à la seconde, {\lstset{style=lua}\lstinline$false$} sinon. Dans le cas des string, on utilise l'ordre lexicographique.\\
  {\lstinline$a % b$} & \textbf{mod} & Calcule le modulo de \texttt{a} dans la base \texttt{b}\\
  {\lstinline$a * b$} & \textbf{mul} & Effectue la multiplication de deux doubles.\\
  & \textbf{narg} & Spéficie le nombre d'arguments d'une fonction ordinaire.\\
  & \textbf{nargs} & Spéficie le nombre d'arguments d'une fonction variadique.\\
  {\lstinline$-a$} & \textbf{neg} & Inverse le signe du nombre \texttt{a}.\\
  {\lstinline$x == y$} & \textbf{neq} & Effectue la comparaison de \texttt{x} avec \texttt{y}, si \texttt{x} et \texttt{y} sont des string ou des doubles, cette comparaison compare l'objet pointé et non les pointeurs. Retourne {\lstset{style=lua}\lstinline$true$} si les valeurs sont différentes, {\lstset{style=lua}\lstinline$false$} sinon.\\
  {\lstset{style=lua}\lstinline${,[x] = y}$} & \textbf{new} & Ajoute un élément à la table en cours de à l'index spécifié.\\
  {\lstset{style=lua}\lstinline$not x$} & \textbf{not} & \texttt{x} prend la valeur {\lstset{style=lua}\lstinline$true$} si \texttt{x} vaut {\lstset{style=lua}\lstinline$nil$} ou {\lstset{style=lua}\lstinline$false$}, et la valeur {\lstset{style=lua}\lstinline$false$} dans tous les autres cas.\\
  & \textbf{num} & Pousse un double sur la pile.\\
  {\lstinline$x or y$} & \textbf{or} & Si \texttt{x} n'est pas {\lstset{style=lua}\lstinline$false$} ou {\lstset{style=lua}\lstinline$nil$}, retourne \texttt{x}, sinon poursuit l'exécution à \texttt{y}, et retourne \texttt{y}\\
  {\lstset{style=lua}\lstinline$f(x)$} & \textbf{params} & Débute l'évaluation des paramètres d'une fonction à venir.\\
  & \textbf{place} & Suite à \texttt{\textbf{chg}}, consolide la pile de destinations avant de recevoir les valeurs.\\
  {\lstinline$a ^ b$} & \textbf{pow} & Effectue de calcul de \texttt{a} à la puissance \texttt{b}, si \texttt{a} est négatif, alors \texttt{b} doit impérativement être un entier sans quoi le résultat est indéfini.\\
  {\lstset{style=lua}\lstinline${,[x] = y}$} & \textbf{put} & Suite à \texttt{\textbf{new}} ou \texttt{\textbf{append}}, place le dernier élément à la place voulue dans la table.\\
  {\lstset{style=lua}\lstinline$a$} & \textbf{ref} & Réfère à une variable locale sur la pile.\\
   & \textbf{rend} & Marque la fin de l'environnement {\lstset{style=lua}\lstinline$repeat$}.\\
  {\lstset{style=lua}\lstinline$repeat$} & \textbf{repeat} & Marque le début de l'environnement {\lstset{style=lua}\lstinline$repeat$}.\\
   & \textbf{req} & Charge un autre programme lua.\\
  & \textbf{rfct} & Retourne l'adresse de la fonction spécifiée.\\
  {\lstset{style=lua}\lstinline$local x = y$} & \textbf{set} & Débute l'empilage de valeurs.\\
  & \textbf{stack} & Suite à \texttt{\textbf{set}}, consolide la pile. Suite à \texttt{\textbf{place}} effectue le transfert des valeurs vers les destinations.\\
  & \textbf{struct} & Inquique que la valeur finale est en position pour retourner plusieurs valeurs.\\
  {\lstset{style=lua}\lstinline$"..."$} & \textbf{str} & Pousse une chaîne de caractères.\\
  {\lstinline$a - b$} & \textbf{sub} & Effectue la soustraction de deux doubles.\\
  {\lstset{style=lua}\lstinline$,$} & \textbf{tac} & Marque la séparation de deux éléments.\\
  {\lstset{style=lua}\lstinline$return f(x)$} & \textbf{tcall} & Appel terminal de la fonction spécifiée par \texttt{\textbf{params}}.\\
  {\lstset{style=lua}\lstinline$then$} & \textbf{then} & Marque le début de la première branche du {\lstset{style=lua}\lstinline$if$}.\\
  {\lstset{style=lua}\lstinline$x, y, (z)$} & \textbf{trunc} & Supprimes les valeurs de retour supplémentaires\\
  {\lstset{style=lua}\lstinline$until$} & \textbf{until} & Test la condition de sortie de la boucle {\lstset{style=lua}\lstinline$repeat$}.\\
  {\lstset{style=lua}\lstinline$$} & \textbf{var} & Réfère à une variable à l'extérieur du programme.\\
  {\lstset{style=lua}\lstinline$do$} & \textbf{wdo} & Teste la condition de sortie de la boucle while {\lstset{style=lua}\lstinline$while$}.\\
  {\lstset{style=lua}\lstinline$end$} & \textbf{wend} & Termine la boucle while {\lstset{style=lua}\lstinline$while$}.\\
  {\lstset{style=lua}\lstinline$while$} & \textbf{while} & Marque le début de la boucle while {\lstset{style=lua}\lstinline$while$}.\\
  
  
\end{longtable}
\end{document}
